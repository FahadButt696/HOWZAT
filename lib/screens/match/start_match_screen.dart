import 'package:dropdown_button2/dropdown_button2.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:firebase_core/firebase_core.dart'; // Added Firebase Core import
import 'package:cloud_firestore/cloud_firestore.dart'; // Added Firestore import
import 'package:uuid/uuid.dart'; // Import for UUID generation


import '../../models/batting_stats.dart';
import '../../models/bowling_stats.dart';
import '../../models/fielding_stats.dart';
import '../../models/match_model.dart';
import '../../models/player_stats_model.dart';
import '../../models/team_model.dart';
import '../../routes/app_routes.dart';
import '../../services/match_service.dart';
import '../../services/team_service.dart';

class StartMatchScreen extends StatefulWidget {
  final Map<String, dynamic> matchData;

  const StartMatchScreen({
    super.key,
    required this.matchData,
  });

  @override
  State<StartMatchScreen> createState() => _StartMatchScreenState();
}

class _StartMatchScreenState extends State<StartMatchScreen> {
  String? striker;
  String? nonStriker;
  String? bowler;

  // Firestore and Service instances
  late FirebaseFirestore _firestore;
  late MatchService _matchService;
  late TeamService _teamService;
  late String _appId; // To get the app ID from the environment
  late String _userId; // User ID from Firebase Auth

  // Uuid generator instance
  final Uuid _uuid = const Uuid();

  @override
  void initState() {
    super.initState();
    _initFirebaseAndServices();
  }

  void _initFirebaseAndServices() {
    // Initialize Firebase if not already initialized
    if (Firebase.apps.isEmpty) {
      // Access global firebaseConfig variable provided by the Canvas environment
      final firebaseConfig = Map<String, dynamic>.from(const String.fromEnvironment('FIREBASE_CONFIG') == ''
          ? {}
          : Map<String, dynamic>.from(const String.fromEnvironment('FIREBASE_CONFIG') as dynamic));

      Firebase.initializeApp(
        options: FirebaseOptions(
          apiKey: firebaseConfig['apiKey'] ?? '',
          appId: firebaseConfig['appId'] ?? '',
          messagingSenderId: firebaseConfig['messagingSenderId'] ?? '',
          projectId: firebaseConfig['projectId'] ?? '',
          storageBucket: firebaseConfig['storageBucket'] ?? '',
        ),
      );
    }

    _firestore = FirebaseFirestore.instance;

    // Access global __app_id variable provided by the Canvas environment
    _appId = const String.fromEnvironment('APP_ID', defaultValue: 'default-app-id');

    // Get the current user ID. This assumes user is already logged in or will be by this point.
    // For robust production apps, you'd want to listen to auth state changes.
    final currentUser = FirebaseAuth.instance.currentUser;
    if (currentUser == null) {
      // Handle the case where user is not logged in, perhaps navigate to login screen
      // For now, setting a dummy ID or throwing an error
      _userId = 'anonymous_user'; // Fallback
      print("Warning: User not logged in. Using anonymous_user ID for services.");
      // In a real app, you might want to await signInAnonymously here if no user.
    } else {
      _userId = currentUser.uid;
    }


    _matchService = MatchService(_firestore, _appId, _userId);
    _teamService = TeamService(_firestore, _appId, _userId);
  }


  Future<void> _startMatch() async {
    if (striker == null || nonStriker == null || bowler == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please select all fields'),
          behavior: SnackBarBehavior.floating,
        ),
      );
      return;
    }

    // Proceed with match start logic
    print('Striker: $striker');
    print('Non-Striker: $nonStriker');
    print('Bowler: $bowler');


    final DateTime now = DateTime.now();

    // Calculate end time based on overs (1 over = approx 4 minutes)
    final DateTime endTime = now.add(Duration(minutes: widget.matchData['overs'] * 4));

    // Reverting to previous player list handling as requested
    final List<String> teamAPlayers = List<String>.from(widget.matchData['teamAPlayers'] ?? []);
    final List<String> teamBPlayers = List<String>.from(widget.matchData['teamBPlayers'] ?? []);


    // Create a mutable MatchModel instance initially
    MatchModel match = MatchModel( // Changed to non-final to allow modification
      id: '', // will be generated by Firestore
      teamA: widget.matchData['teamA'],
      teamB: widget.matchData['teamB'],
      teamAPlayers: teamAPlayers, // Use the filtered list
      teamBPlayers: teamBPlayers, // Use the filtered list
      tossWonBy: widget.matchData['tossWonBy'],
      optedTo: widget.matchData['optedTo'],
      striker: striker!,
      nonStriker: nonStriker!,
      bowler: bowler!,
      startTime: now,
      endTime: endTime,
      overs: widget.matchData['overs'],
      status: 'ongoing',
      result: 'No Result',
    );

    // Save match to backend and get the generated match ID
    final String matchId = await _matchService.saveMatch(match);

    // Update the match object with the generated ID for passing to LiveScoreScreen
    match = MatchModel( // Recreate MatchModel with the generated ID
      id: matchId,
      teamA: match.teamA,
      teamB: match.teamB,
      teamAPlayers: match.teamAPlayers,
      teamBPlayers: match.teamBPlayers,
      tossWonBy: match.tossWonBy,
      optedTo: match.optedTo,
      striker: match.striker,
      nonStriker: match.nonStriker,
      bowler: match.bowler,
      startTime: match.startTime,
      endTime: match.endTime,
      overs: match.overs,
      status: match.status,
      result: match.result,
    );

    print('Generated Match ID: $matchId');

    // Generate unique IDs for teams since they are not passed from previous screen
    final String teamAId = _uuid.v4();
    final String teamBId = _uuid.v4();


    // Create TeamModels with players for the match
    final teamA = TeamModel(
      id: teamAId, // Use the newly generated ID
      name: match.teamA,
      matchesPlayed: 0, // This will be updated by TeamService if match completes
      wins: 0,
      losses: 0,
      players: teamAPlayers.map((name) => PlayerModel( // Use the filtered list
        id: name, // Assuming player name is unique enough for ID or you have actual player IDs
        name: name,
        batting: BattingStats(),
        bowling: BowlingStats(),
        fielding: FieldingStats(),
      )).toList(),
    );

    final teamB = TeamModel(
      id: teamBId, // Use the newly generated ID
      name: match.teamB,
      matchesPlayed: 0, // This will be updated by TeamService if match completes
      wins: 0,
      losses: 0,
      players: teamBPlayers.map((name) => PlayerModel( // Use the filtered list
        id: name,
        name: name,
        batting: BattingStats(),
        bowling: BowlingStats(),
        fielding: FieldingStats(),
      )).toList(),
    );

    // Save teams. The `saveTeam` method in TeamService will also save players as subcollections.
    await _teamService.saveTeam(teamA);
    await _teamService.saveTeam(teamB);

    Navigator.pushNamed(
      context,
      AppRoutes.LiveScore,
      arguments: {
        'userId': _userId, // Use the _userId derived from Firebase Auth
        'match': match, // Pass the updated match object with the generated ID
        'teamA': teamA,
        'teamB': teamB,
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      extendBodyBehindAppBar: true,
      backgroundColor: Colors.transparent,
      body: Container(
        width: double.infinity,
        height: double.infinity,
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            colors: [Color(0xFF0B6623), Color(0xFF1E3C72)],
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
          ),
        ),
        child: SafeArea(
          child: Column(
            children: [
              const SizedBox(height: 10),
              Padding(
                padding: const EdgeInsets.only(left: 16.0, top: 8.0),
                child: Align(
                  alignment: Alignment.centerLeft,
                  child: IconButton(
                    icon: const Icon(Icons.arrow_back_ios, color: Colors.white),
                    onPressed: () => Navigator.pop(context),
                  ),
                ),
              ),
              Center(
                child: Text(
                  "Start Match",
                  style: GoogleFonts.balooBhai2(
                    fontSize: 24,
                    color: Colors.white,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              const SizedBox(height: 20),

              // üèè Striker Dropdown
              _dropdownBox(
                label: "Striker Batsman",
                value: striker,
                items: List<String>.from(widget.matchData['teamAPlayers'] ?? []),
                onChanged: (val) => setState(() => striker = val),
              ),

              // üèè Non-Striker Dropdown
              _dropdownBox(
                label: "Non-Striker Batsman",
                value: nonStriker,
                items: List<String>.from(widget.matchData['teamAPlayers'] ?? []),
                onChanged: (val) => setState(() => nonStriker = val),
              ),

              // üéØ Bowler Dropdown
              _dropdownBox(
                label: "Bowler",
                value: bowler,
                items: List<String>.from(widget.matchData['teamBPlayers'] ?? []),
                onChanged: (val) => setState(() => bowler = val),
              ),

              const Spacer(),

              // ‚úÖ Start Match Button
              Padding(
                padding: const EdgeInsets.symmetric(vertical: 20),
                child: Container(
                  decoration: BoxDecoration(
                    gradient: const LinearGradient(
                      colors: [Color(0xFF00C853), Color(0xFF64DD17)],
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                    ),
                    borderRadius: BorderRadius.circular(30),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black45.withOpacity(0.3),
                        blurRadius: 8,
                        offset: const Offset(2, 4),
                      ),
                    ],
                  ),
                  child: ElevatedButton(
                    onPressed: _startMatch,
                    style: ElevatedButton.styleFrom(
                      elevation: 0,
                      backgroundColor: Colors.transparent,
                      shadowColor: Colors.transparent,
                      padding: const EdgeInsets.symmetric(horizontal: 40, vertical: 16),
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),
                    ),
                    child: Text(
                      "Start Match",
                      style: GoogleFonts.balooBhai2(
                        fontSize: 16,
                        color: Colors.white,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
  Widget _dropdownBox({
    required String label,
    required String? value,
    required List<String> items,
    required ValueChanged<String?> onChanged,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
      child: DropdownButtonHideUnderline(
        child: DropdownButton2<String>(
          isExpanded: true,
          hint: Text(
            label,
            style: GoogleFonts.balooBhai2(color: Colors.white70),
          ),
          value: value,
          items: items.map((item) {
            return DropdownMenuItem<String>(
              value: item,
              child: Text(
                item,
                style: const TextStyle(color: Colors.white),
              ),
            );
          }).toList(),
          onChanged: onChanged,
          buttonStyleData: ButtonStyleData(
            height: 55,
            padding: const EdgeInsets.symmetric(horizontal: 16),
            decoration: BoxDecoration(
              color: Colors.black.withOpacity(0.4),
              borderRadius: BorderRadius.circular(14),
              border: Border.all(color: Colors.white24),
            ),
          ),
          dropdownStyleData: DropdownStyleData(
            maxHeight: 250, // Limits height, adds scroll
            padding: EdgeInsets.zero,
            decoration: BoxDecoration(
              color: const Color(0xFF212121),
              borderRadius: BorderRadius.circular(12),
            ),
            elevation: 8,
            offset: const Offset(0, -4), // slight adjustment if needed
          ),
          iconStyleData: const IconStyleData(
            icon: Icon(Icons.arrow_drop_down, color: Colors.white),
          ),
        ),
      ),
    );
  }

}
